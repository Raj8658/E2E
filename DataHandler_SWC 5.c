/**
 * \file
 *
 * \brief AUTOSAR Rte
 *
 * This file contains the implementation of the AUTOSAR
 * module Rte.
 *
 * \version 6.4.11
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

/*
 * This file contains an Rte component template / example code
 *
 * This file has been automatically generated by
 * EB tresos AutoCore Rte Generator Version 6.4.11
 * on Fri Sep 08 10:50:00 IST 2023. !!!IGNORE-LINE!!!
 */

/*
 * \addtogroup Rte Runtime Environment
 * @{
 */

/* ==================[Includes]=============================================== */
#include <Rte_SWC_DataHandler.h>
static DT_BpsComPdu DataHandler_receiveRawData;
#define E2E_P02STATUS_OK 			0x0U  /**< New data has been correctly received. */
#define E2E_P02STATUS_OKSOMELOST 	0x1U  /**< New data has been correctly received, but some data in the sequence have been probably lost. */
#define E2E_P02STATUS_WRONGCRC 		0x2U  /**< The data has been received according to communication medium, but the CRC is incorrect. */
#define E2E_P02STATUS_REPEATED 	    0x3U  /**< New data has been correctly received, but the Counter is identical to the most recent Data */
#define E2E_CRCERROR				TRUE
#define BPS_Factor 					0.0879f
#define APS_Factor  				0.1f
#define SASOffset               	-3276.8f
static boolean WaitForFirstData_SAS = TRUE;
static uint8 LastValidCounter_SAS;
uint16 Age_Error_SAS = 0;
uint16 SAS_Age = 0;
static DT_ApsPduIncnvn TX_SAS =
{
   0U,
   0U,
   0U,
   0U,
   0.0f,
   0U,
   0U
 };
Std_ReturnType ret_Write_1_APS;
/* ==================[Definition of functions with external linkage]========== */
/* ------------------------[runnable entity skeletons]------------------------ */
FUNC(void, RTE_CODE) SWC_ComAdapter_Runnable_ComAdapter (void)
{
  DT_BpsPduInCnvn arg_Write_data = 
  {
	0.0f,
	0U,
	0.0f,
	0U
  };
  Std_ReturnType ret_Write;
  boolean arg_Write_data_1 = 0U;
  Std_ReturnType ret_Write_1;
  DT_BpsComPdu arg_Read_data;
  Std_ReturnType ret_Read;
  boolean arg_Read_data_0;
  Std_ReturnType ret_Read_0;
  DT_SG_ID00E_HwaA_RwaA arg_Read_data_SAS;
  Std_ReturnType ret_Read_SAS;

  static DT_BpsPduInCnvn DT_BpsPduInCnvn_sendVal;

  (void)ret_Write;
  ret_Write = Rte_Write_P_BpsComPduCnvn_BpsPduInCnvn(&arg_Write_data);
  (void)ret_Write_1;
  ret_Write_1 = Rte_Write_P_Clamp30Enad_Clamp30Enad(arg_Write_data_1);
  (void)ret_Read;
  ret_Read = Rte_Read_R_BpsComPdu_BpsComPdu(&arg_Read_data);
  (void)ret_Read_0;
  ret_Read_0 = Rte_Read_R_Clamp30Enad_Clamp30Enad(&arg_Read_data_0);
  
  /*loharrha: SENT Interface implementation start*/
  Rte_Read_R_BpsComPdu_BpsComPdu(&DataHandler_receiveRawData); /*Read raw data and Channel State from TAS. */
  DT_BpsPduInCnvn_sendVal.S_Bps_BallnutPrimAgRel_na = DataHandler_receiveRawData.S_Bps_BallnutPrimAg_na * BPS_Factor;
  DT_BpsPduInCnvn_sendVal.S_Bps_BallnutSecnAgRel_na = DataHandler_receiveRawData.S_Bps_BallnutSecnAg_na * BPS_Factor;
  DT_BpsPduInCnvn_sendVal.Q_Bps_BallnutPrimAgRel_na = DataHandler_receiveRawData.Q_Bps_BallnutPrimAg_na;
  DT_BpsPduInCnvn_sendVal.Q_Bps_BallnutSecnAgRel_na = DataHandler_receiveRawData.Q_Bps_BallnutSecnAg_na;
  Rte_Write_P_BpsComPduCnvn_BpsPduInCnvn(&DT_BpsPduInCnvn_sendVal);
  /* loharrha: SENT Interface implementation End */
  /* Timeout Call for SAS */
 (void)ret_Read_SAS;
   ret_Read_SAS = Rte_Read_R_ApsComPdu_SG_ID00E_HwaA_RwaA(&arg_Read_data_SAS);
  if((ret_Read_SAS & RTE_E_MAX_AGE_EXCEEDED) == RTE_E_MAX_AGE_EXCEEDED)
  	{
  		//(void)ret_Write_Tout;
  		//ret_Write_Tout = Rte_Write_P_S_MsgApsTiOutDetd_na_TimeoutStatus(TRUE);   /* A timeout has occurred and has been reported */
  		WaitForFirstData_SAS = TRUE;
  	}
} /* FUNC(void, RTE_CODE) SWC_ComAdapter_Runnable_ComAdapter (void) */

FUNC(void, RTE_CODE) SWC_DataHandler_Runnable_SAS (void)
{
  uint8 u8err_statusCrc = 0U;        /* err_statusorary Variable for checksum calculation */
  uint8 u8ChecksumRx = 0U;        /* Received checksum in 4 bit */
  uint8 u8Cnt = 0U;
  uint8 u8CalcCrc = 0U;
  uint8 u8data[4] = {0U,0U,0U,0U};
  uint8 E2EP02_COUNTER_MAX =15U;
  uint8 ReceivedCounter;
  uint8 DeltaCounter;
  uint8 err_status = E2E_P02STATUS_OK;
  DT_SG_ID00E_HwaA_RwaA arg_Read_data_SAS;
  Std_ReturnType ret_Read_SAS;

  float SAS_DecVal = 0.0f;
  uint8 E2E_CrcRes_SAS = 0U;
  boolean E2E_SeqRes_SAS = FALSE;
  /* Implementation Of SAS : */
  /* Read from CAN Bus and send to SwcInp */
  //(void)ret_Write_1_APS;
 // ret_Write_1_APS = Rte_Write_P_ApsPduIncnvn_ApsPduIncnvn(&TX_SAS);
  (void)ret_Read_SAS;
  ret_Read_SAS = Rte_Read_R_ApsComPdu_SG_ID00E_HwaA_RwaA(&arg_Read_data_SAS);
  u8ChecksumRx  = arg_Read_data_SAS.S_Hwa_Checksum;
  u8Cnt= arg_Read_data_SAS.S_Hwa_MsgCount;
  u8data[0] = (arg_Read_data_SAS.S_Hwa_Angle & 0x00FF);/*LSB Byte 1 */
  u8data[1] = (arg_Read_data_SAS.S_Hwa_Angle & 0xFF00) >> 8;/*MSB Byte 0 */
  u8data[2] = arg_Read_data_SAS.S_Hwa_Speed;/*Byte 2 */
  u8data[3] = (arg_Read_data_SAS.S_Hwa_Status_OK) | (arg_Read_data_SAS.S_Hwa_Status_CAL<<1) |   (arg_Read_data_SAS.S_Hwa_Status_TRIM << 2) | (arg_Read_data_SAS.S_Hwa_Internal_Status_FLAGS<<3);
  u8err_statusCrc = u8data[0] ^ u8data[1] ^ u8data[2] ^ u8data[3];
  u8CalcCrc = (u8err_statusCrc >> 4) ^ (u8err_statusCrc & 0x0F) ^ u8Cnt;
  if(u8CalcCrc == u8ChecksumRx)
   	{
   		/* correct CRC */
   		//counter check
  		ReceivedCounter= u8Cnt;
  		if (TRUE == WaitForFirstData_SAS)
  		 {
  			/* first data received since init or reinit
  			 * (sequence counter cannot be checked) */
  			WaitForFirstData_SAS = FALSE;
  			LastValidCounter_SAS = ReceivedCounter;
  		 }
  		else
  		 {
  			/* check sequence counter */
  			DeltaCounter = (ReceivedCounter >= LastValidCounter_SAS) ?
  						   (ReceivedCounter - LastValidCounter_SAS) :
  						   ((ReceivedCounter + E2EP02_COUNTER_MAX + 1U) - LastValidCounter_SAS);
  			if (1U == DeltaCounter)
  		     {
  				/* the Counter is incremented by 1, i.e. no Data has
  				 * been lost since the last correct data reception. */
  			    err_status = E2E_P02STATUS_OK;
  		     }
  			else if (1U < DeltaCounter)
  			 {
  			   /* the Counter is incremented by DeltaCounter
  				* (1 < DeltaCounter), i.e.
  				* some Data in the sequence have been probably lost since
  				* the last correct/initial reception, but this is within
  				* the configured tolerance range. */
  				err_status = E2E_P02STATUS_OKSOMELOST;
  			 }
  			 #if FALSE
  			 else if (DeltaCounter == 0U) /* DeltaCounter == 0U */
  		     {
  				 /* the counter is identical, i.e. data has already been
  				  * received (repeated message) */
  				 /* Increment counter for consecutively missing or repeated Data */
  				err_status = E2E_P02STATUS_REPEATED;
  		     }
  			 #endif
  		    else
  			 {
  				 /* Do Nothing */
  			 }

  		    LastValidCounter_SAS = ReceivedCounter;
  		  }
  		E2E_SeqRes_SAS = err_status;
   	 }
   	else
  	{
  	  /* wrong CRC */
  	  err_status = E2E_P02STATUS_WRONGCRC;
  	  E2E_CrcRes_SAS = E2E_CRCERROR;
  	}

   TX_SAS.ApsCalSt = arg_Read_data_SAS.S_Hwa_Status_CAL;
   TX_SAS.ApsFailrSt = arg_Read_data_SAS.S_Hwa_Status_OK;
   TX_SAS.ApsStFlgs = arg_Read_data_SAS.S_Hwa_Internal_Status_FLAGS;
   TX_SAS.ApsTrimSt = arg_Read_data_SAS.S_Hwa_Status_TRIM;
	if(E2E_CrcRes_SAS== 1 || E2E_SeqRes_SAS == 1)
	  {
		Age_Error_SAS = 1;
	  }
	else
	  {
		Age_Error_SAS = 0;
	  }

   /*This implementation is for handling IEEE754 representation of float values*/
	if(arg_Read_data_SAS.S_Hwa_Angle <= 0x7FFF && arg_Read_data_SAS.S_Hwa_Angle>=0x0)
	{
		SAS_DecVal = (float)(arg_Read_data_SAS.S_Hwa_Angle*APS_Factor);
	}
	else if(arg_Read_data_SAS.S_Hwa_Angle >= 0x8001 && arg_Read_data_SAS.S_Hwa_Angle <= 0xFFFF)
	{
		SAS_DecVal = (float)(((arg_Read_data_SAS.S_Hwa_Angle - 0x8001) * APS_Factor) + SASOffset + APS_Factor);
	}

	TX_SAS.ApsAg      =  SAS_DecVal;
	TX_SAS.MsgApsE2eChkSts      =  err_status;

} /* FUNC(void, RTE_CODE) SWC_DataHandler_Runnable (void) */
FUNC(void, RTE_CODE) Calculate_Age_SAS (void)
{

	if(Age_Error_SAS == 1 || WaitForFirstData_SAS == 1)
	{
		if(SAS_Age<65535)
			SAS_Age++;
	}
	else{
		SAS_Age=0;
	}
	TX_SAS.MsgApsAge = SAS_Age;
	(void)ret_Write_1_APS;
	ret_Write_1_APS = Rte_Write_P_ApsPduCnvn_ApsPduIncnvn(&TX_SAS);

} /* FUNC(void, RTE_CODE) Calculate_Age_SAS (void) */
/*
  ------------------------[runnable-independent API]-------------------------

  Copy and paste the following API to those runnable entity functions where
  you want to use them.

  ------------------------[port handle API]----------------------------------
  ------------------------[per instance memory API]--------------------------
 */

/** @} doxygen end group definition  */
/* ==================[end of file]============================================ */
